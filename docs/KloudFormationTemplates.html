---
layout: default
title: KloudFormation Templates
nav_order: 2
---
<html>
  <head>
    <meta charset="utf-8">
    <title>KloudFormation Templates</title>
    <script src="https://unpkg.com/kotlin-playground@1" data-selector="code"></script>
    <script>document.getElementsByClassName("site-title")[0].text = "KloudFormation"</script>
  </head>
  <body>
    <h1>KloudFormation Templates</h1>
    <p>KloudFormation provides a way to build templates that modularise parts of Cloudformation for users.</p>
    <p>For example, building an S3 website is a regular task that can be wrapped into a function.</p>
    <code data-highlight-only>
        s3Website { }
    </code>
    <p>Using the pattern outlined here with Modules you can grant the user access to all of the parts that make up a module</p>
    <p>The user experience looks like this: </p>
    <code data-highlight-only>
s3Website {
    s3Bucket {
        props { errorDocument = "404.html" } // Access to modify properties specified by the template builder
        modify { bucketName("NewBucketName") } // Full access to KloudFormation here
    }
    s3Distribution(+"klouds.io") // An optional Submodule attaches a domain
}
    </code>

    <h2>Building a Module</h2>
    <p>A <strong>Module</strong> is simply a packaged up set of KloudFormation steps that create Cloudformation template parts.</p>
    <p>They are made up of <strong>Parts</strong> that can be modified by the user.</p>
    <p>A Part can be anything but will most likely be a Cloudformation Resource or a <strong>SubModule</strong></p>
    <p>A <strong>SubModule</strong> is a <strong>Module</strong> that requires <strong>Predefined</strong> information from a parent <strong>Module</strong> in order to build its <strong>Parts</strong></p>

    <p>Here is the basic structure of a Module with no parts</p>
    <code data-highlight-only>
class MyModule: Module {
    class Parts
    class Builder: ModuleBuilder&ltMyModule, Parts&gt(Parts()){
        override fun KloudFormation.buildModule(): Parts.() -> MyModule = {
            // KloudFormation here
            MyModule()
        }
    }
}
val myModule = builder(MyModule.Builder())
    </code>
    <p>The user can then invoke that within KloudFormation as follows: </p>
    <code data-highlight-only>
// The Parts instance is passed as the receiver inside the brackets
// This will be useful later when we include parts
myModule { }
    </code>
    <h2>Parts</h2>
    <p>The Parts class represents the individual parts that go into making a Module</p>
    <p>For example an S3Bucket is a part of the S3Website Module</p>
    <p>Anything within the Parts class will be passed to the user</p>
    <p>A Part can be represented using the Modification type. Here is an example of the s3Bucket part within the S3Website Module</p>
    <code data-highlight-only>
        val s3Bucket = modification&ltBucket.Builder, Bucket, BucketProps&gt()
    </code>
    <h3>Modification</h3>
    <p>A Modification represents a single item that the user has access to modify.</p>
    <p>A Modification can be created using one of the <em>modification()</em> or <em>optionalModification()</em> functions</p>
    <p>It takes three type parameters, a Builder, the thing your building and a Properties type</p>
    <p>The Properties type should have mutable variables</p>
    <p>Modifications present to the user granting them the opportunity to modify properties and have access to the Builder of the resource</p>
    <code data-highlight-only>
// When a modification is invoked by the user it surfaces two methods ( props and modify )
s3Bucket {
    props { /* this is BucketProps */ }
    modify { /* this is Bucket.Builder */ }
}
    </code>

    <h2>S3 Website Example</h2>
  <p>...</p>
  </body>
</html>